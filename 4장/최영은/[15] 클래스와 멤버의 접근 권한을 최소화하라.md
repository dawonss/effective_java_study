## 15. 클래스와 멤버의 접근 권한을 최소화 하라
* **정보 은닉**(= **캡슐화**) : **클래스 내부 데이터와 내부 구현 정보**를 **외부 컴포넌트로부터 완벽히 숨겨** 구현과 API를 깔끔히 분리
    * 오직 **API만을 통해 타 컴포넌트와 소통하고 서로의 내부 동작 방식은 알 수 없음**
### 1️⃣ 정보 은닉의 장점
* 컴포넌트들의 독립!
1. 여러 컴포넌트들 **병렬 개발 가능**
2. 각 **컴포넌트 파악 및 디버깅을 빠르게** 할 수 있음 : 시스템 관리 비용이 감소
3. 원하는, **필요한 컴포넌트만 최적화 가능** : 성능 최적화에 도움을 줌
4. 외부에 거의 의존하지 않고 독립적인, 혼자 동작할 수 있는 컴포넌트의 경우 넟선 환경에서도 사용될 수 있어 **SW 재사용성이 높아짐**
5. **개별 컴포넌트의 동작 검증, 테스트가 가능**해짐 : 규모가 큰 시스템의 제작 난이도가 내려간다, 낮아진다)
* **정보 은닉의 핵심**은 **접근 제어 메커니즘**
    * 클래스, 인터페이스, 멤버의 접근성은 그 요소가 선언된 위치 및 접근 제한자로 정해지며 **모든 클래스, 멤버의 접근성은 가능한 좁게 설정해야 한다**.
    * 즉, **가장 낮은 접근 수준을 부여**해야 한다.
### 2️⃣ 톱레벨 클래스와 인터페이스
* **접근 제한자로 public과 package-private 선언 가능**
1. public : **공개API**로 되어 하위 호환을 위해 관리가 필요함
2. pakage-private : **패키지 내에서만 이용 가능**하여 내부 구현이 되고 언제든 수정이 가능하며 그로인해 클라이언트에 아무런 피해가 가지 않음
* 한 클래스에서만 사용하는 package-private 클래스 or 인터페이스는 이를 사용하는 클래스의 private static 내부 클래스로 중첩 하여 사용하자
    * 그러면 패키지 전체가 아닌 중첩된 바깥 클래스만 해당 클래스를 사용할 수 있음
* 클래스가 public일 필요가 없다면 package-private으로 톱레벨 클래스의 접근 제한을 좁히자
### 3️⃣ 접근 제한자 종류
1. private : 비공개. 클래스 내부에서만 사용 가능
2. package-private : 해당 클래스가 존재하는 패키지 내에서만 접근 가능
3. protected : 해당 클래스가 존재하는 패키지와 더불어 상속하는 하위 클래스까지 접근 가능
4. public : 공개애
* 1과 2는 내부 클래스 구현에 해당하여 공개 API에 영향을 주지 않음
* 클래스의 공개 API에 해당되지 않는 멤버들은 전부 private으로 선언한다
* 같은 패키지의 클래스가 접근해야하는 멤버들만 package-private으로 수정한다
### 4️⃣ 주의 사항
1. Serializable을 구현한 클래스의 경우, 필드들이 의도치 않게 공개 API가 될 수 있다
2. public 클래스의 protected 멤버 수는 적을 수록 좋다
3. 상위 클래스의 메서드를 재정의 하는 경우는 리스코프 치환의 원칙에 따라 접근성을 상위 클래스보다 좁힐 수 없다
4. 클래스가 인스턴스를 구현하는 경우에는 인터페이스가 정의한 모든 메서드는 public으로 선언해야한다
5. 코드 테스트를 목적으로 클래스, 인터페이스, 멤버의 접근 범위를 공개 API로 만들어서는 안된다
### 5️⃣ public 클래스의 인스턴스 필드는 public으로 하지 않는다
1. 필드가 **가변 객체를 참조** 혹은 **final이 아닌 인스턴스 필드**를 public 으로 풀어주는 경우 **해당 필드에 담을 수 있는 값을 제한할 수 없다**
    * public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다
    * 필드가 final이면서 불변 객체를 참조한다 하여도 문제는 여전하다
    > 🤔 **내 생각** <br>
    > **참조된 객체 자체는 내부 값은 수정될 수 있기 때문**이라고 하는데 객체의 경우 주소값을 갖고 있으니까 **주소만 final로 저장**돼서 (참조돼서) **주소값이 바뀔 수 없는 거지 내부는 보장해줄 수 없고** public이라 **외부에서 손쉽게 접근 할 수 있어서** 그런 것 같음!
2. 클래스가 표현하는 **추상 클래스가 추상 개념을 표현하는 것을 완성하는 데에 필요한 구성요소로의 상수라면 public static final필드로 공개해도 좋다**
    * 이런 필드는 **반드시 기본 타입 값**이나 **불변 객체를 참조**해야 한다
3. 길이가 0이 아닌 배열도 변경이 가능하므로 **클래스에서 public static final 배열 필드를 두거나** 이 필드를 반환하는 **접근자 메서드를 제공해서는 안된다**
    * **클라이언트가 그 배열에 접근하여 내용을 수정할 수 있게 되므로 절대 금지**
```java
// 배열 얘기에 해당하는 코드 : 이럼 안됨!
public static final Thing[] VALUES = {...};
```
```java
// 위의 해결책 1) public 배열을 private으로 변경하고 public 불변 리스트를 추가
private static final Thing[] PRIVATE_VALUES = {...};
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```
> Collections.unmodifiableList() 실행 후 반환된 객체는 수정 메소드(ex. add(), set(), addAll()...)를 호출 할 수 없고 호출 시 UnsupportedOperationException이 발생
```java
// 위의 해결책 2) public 배열을 private으로 변경하고 그 복사본을 반환하는 public메서드를 추가
private static final Thing[] PRIVATE_VALUES = {...};
public static final Thing[] values() {
  return PRIVATE_VALUES.clone();
}
```
> clone()을 사용하여 복사본을 반환
### 6️⃣ 모듈
* 패키지가 클래스들의 묶음이라면 모듈은 **패키지들의 묶음**
* 자신에 속하는 패키지 중 **공개할 것들을 module-info.java에 선언**하여야 함
    * public, protected 멤버라도 여기에 **적지 않으면** (해당 클래스가 속하는 패키지를 공개하지 않으면) **모듈 외부에서는 접근할 수 없다**
    * 모듈 시스템 활용 시, 클래스를 외부에 공개하지 않으면서 같은 모듈 내의 패키지 사이에서는 자유롭게 공유 할 수 있음
* 외부에 **공개되지 않도록 숨겨진 패키지 내부의 public 클래스의 public or protected 멤버는 접근제한자의 효과가 모듈 내부로 한정되고 외부에서는 접근이 금지된다**
* 또한 모듈의 jar 파일을 모듈 경로가 아닌 애플리케이션의 클래스 패스에 두면 모듈 내 패키지들은 모듈이 없는 것처럼 행동한다
    * 이렇게 되면 모듈이 공개 했는지 여부와 상관없이 모듈 밖에서도 public, protected 멤버들에 그대로 접근할 수 있게 된다
* 이를 적극 활용한 예 : JDK
    * 자바 라이브러리에서 공개하지 않은 패키지 들은 해당 모듈 밖에서는 절대 접근할 수 없음
* 모듈화를 위해 할 일 (과정)
  1. 패키지를 모듈 단위로 묶기
  2. 모듈 선언에 패키지 들의 모든 의존성을 명시
  3. 모듈 내부의 소스 트리를 재배치
  4. 모듈 안으로부터 모듈 시스템을 적용하지 않는 일반 패키지로의 모든 접근에 특별한 조치를 취하기
## ❗ 핵심 요약
1. **프로그램 요소의 접근성은 가능한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API를 설계하자**
2. 그 외의 클래스, 인터페이스, 멤버는 의도치 않게 API로 공개되지 않도록 한다
3. **public클래스는 상수용 public static final 필드 외에는 어떠한 public 필드를 갖지 않도록 한다**
4. **public static final 필드는 해당 필드가 참조하는 객체가 불변인 경우에만 사용한다**
